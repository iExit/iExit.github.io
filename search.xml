<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[搞不清的知识点]]></title>
    <url>%2F2018%2F12%2F29%2F%E6%90%9E%E4%B8%8D%E6%B8%85%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[typeof vs instanceoftoString()和valueOf数据类型基本类型 undefined null boolean number string symbol复杂类型 Objext typeof操作符js是松散类型的，所以需要一种来检测变量的数据类型–typeodtypeof可能返回以下几种情况：undefined–未定义boolean–布尔值string–字符串number–数值object–对象或nullfunction–函数 undefined类型使用var声明但未赋值时，该变量的值就是undefined12var messagealert(message == undefined) // true 1234var message// var agealert(message) // undefinedalert(age) // 报错 未声明的变量传递给alert()函数会报错1234var message// var agealert(typeof message) // undefinedalert(typeof age) // undefined 结果表明，对未初始化和未声明的变量执行 typeof 操作符都返回了undefined 值；这个结果有逻辑上的合理性。因为虽然这两种变量从技术角度看有本质区别，但实际上无论对哪种变量也不可能行真正的操作。12var messagealert(message == undefined) // true null类型null表示为一个空对象指针，所以typeof操作符检测null会返回object12var car = nullalert(typeof car) // object undefined是null的派生，对于一个变量不需要特意设置其为undefined，只要在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值，既提现null的空对象指针特性，又能区别null和undefined。 boolean类型只有来年各个字面值：true和false各种数据类型及对应转换关系——– | ——–|————数据类型 |转换为true|转换为falseboolean | true |falsestring |非空字符串|””(空字符串)number |非零 |0,NaNobject |任何对象 |nullundefined|不适用 |undefined———|———-|———– number类型number类型包括整数和浮点数同时也支持各种数值类型123var intNum = 55 // 十进制var octalNum = 070 // 八进制的56var hexNum = =0x1f // 十六进制的31 在计算过程中，所有八进制和十六进制最终都会被转换成十进制数值。 数值范围 最小数值–Number.MIN_VALUE 最大数值–Number.MAX_VALUE]]></content>
      <categories>
        <category>混淆</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue轮播图插件：vue-awesome-swiper]]></title>
    <url>%2F2018%2F12%2F26%2Fvue%E8%BD%AE%E6%92%AD%E5%9B%BE%E6%8F%92%E4%BB%B6%EF%BC%9Avue-awesome-swiper%2F</url>
    <content type="text"><![CDATA[先用vue-cli新建一个项目install vue-awesome-swiper --save(-S)```123456等待安装，安装完后`package.json`中添加上了`vue-awesome-swiper````js&quot;dependencies&quot;: &#123; &quot;vue&quot;: &quot;^2.5.2&quot;, &quot;vue-awesome-swiper&quot;: &quot;^3.1.3&quot;&#125; 进入main.js123456789101112131415import Vue from 'vue'import App from './App'import vueSwiper from 'vue-awesome-swiper' //引入vue-awesome-swiperimport 'swiper/dist/css/swiper.css' //引入样式Vue.config.productionTip = falseVue.use(vueSwiper) //使用插件/* eslint-disable no-new */new Vue(&#123; el: '#app', components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) swiper的基本结构123&lt;swiper&gt; &lt;swiper-slide class="swiper-slide"&gt;&lt;/swiper-slide&gt;&lt;/swiper&gt; 参考swiper的基本结构，在App.vue中尝试一下123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div id="app"&gt; &lt;div&gt; &lt;swiper&gt; &lt;swiper-slide class="swiper-slide" v-for="(item,index) in slide" :key="index"&gt; 我是第&#123;&#123;item&#125;&#125;个轮播图 &lt;/swiper-slide&gt; &lt;/swiper&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'App', data() &#123; return &#123; slide: [1, 2, 3, 4, 5] &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;.swiper-slide &#123; width: 100%; height: 500px; line-height:500px; font-size: 50px; text-align: center; background-color: rosybrown;&#125;&lt;/style&gt; 成功实现了轮播图的效果，接下来配置一些属性，在App.vue中进行更改123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;template&gt; &lt;div id="app"&gt; &lt;div&gt; &lt;swiper :options="swiperOption"&gt; &lt;swiper-slide class="swiper-slide" v-for="(item,index) in slide" :key="index"&gt; 我是第&#123;&#123;item&#125;&#125;个轮播图 &lt;/swiper-slide&gt; &lt;div class="swiper-pagination" slot="pagination"&gt;&lt;/div&gt; &lt;!-- 分页 --&gt; &lt;div class="swiper-button-prev" slot="button-prev"&gt;&lt;/div&gt; &lt;!-- 箭头左 --&gt; &lt;div class="swiper-button-next" slot="button-next"&gt;&lt;/div&gt; &lt;!-- 箭头右 --&gt; &lt;/swiper&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'App', data() &#123; return &#123; slide: [1, 2, 3, 4, 5], //设置属性 swiperOption: &#123; //显示分页 pagination: &#123; el: '.swiper-pagination', clickable: true //允许分页点击跳转 &#125;, //设置点击箭头 navigation: &#123; nextEl: '.swiper-button-next', prevEl: '.swiper-button-prev' &#125;, //自动轮播 autoplay: &#123; delay: 400 &#125;, //开启循环模式 loop: true, //开启鼠标滚轮控制Swiper切换 mousewheel: true &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;.swiper-slide &#123; width: 100%; height: 500px; line-height: 500px; font-size: 50px; text-align: center; background-color: rosybrown;&#125;&lt;/style&gt; 这样就实现了轮播图更多属性的配置 这样就实现了轮播图更多属性的配置]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas]]></title>
    <url>%2F2018%2F12%2F25%2Fcanvas%2F</url>
    <content type="text"><![CDATA[canvas 最早由Apple引入WebKit,用于Mac OS X 的 Dashboard,后来又在Safari和Google Chrome被实现。基于 Gecko 1.8的浏览器,比如 Firefox 1.5, 同样支持这个元素。&lt;canvas&gt; 元素是WhatWG Web applications 1.0规范的一部分,也包含于HTML 5中。 体验Canvas什么是Canvas？HTML5 的 canvas 元素使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，您可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 创建Canvas元素向 HTML5 页面添加 canvas 元素。规定元素的 id、宽度和高度：1&lt;canvas id="myCanvas" width="200" height="100"&gt;&lt;/canvas&gt; Canvas坐标系通过JavaScript来绘制12345678910/*获取元素*/var myCanvas = document.querySelector('#myCanvas');/*获取绘图工具*/var context = myCanvas.getContext('2d');/*设置绘图的起始位置*/context.moveTo(100,100);/*绘制路径*/context.lineTo(200,200);/*描边*/context.stroke(); Canvas的基本使用图形绘制需要理解些概念： 路径的概念 路径的绘制 描边 stroke() 填充 fill() 闭合路径 手动闭合 程序闭合 closePath() 填充规则(非零环绕) 开启新的路径 beginPath() 设置样式 画笔的状态 lineWidth 线宽，默认1px lineCap 线末端类型：(butt默认)、round、square lineJoin 相交线的拐点 miter(默认)、round、bevel strokeStyle 线的颜色 fillStyle 填充颜色 setLineDash() 设置虚线 getLineDash() 获取虚线宽度集合 lineDashOffset 设置虚线偏移量（负值向右偏移） 实例练习 渐变色绘制 镂空的房子 绘制坐标网格 绘制坐标系 绘制坐标点 绘制折线图 参考文档 w3school Canvas_API Canvas图形绘制矩形绘制 rect(x,y,w,h) 没有独立路径 strokeRect(x,y,w,h) 有独立路径，不影响别的绘制 fillRect(x,y,w,h) 有独立路径，不影响别的绘制 clearRect(x,y,w,h) 擦除矩形区域 圆弧绘制 弧度概念 arc() x 圆心横坐标 y 圆心纵坐标 r 半径 startAngle 开始角度 endAngle 结束角度 anticlockwise 是否逆时针方向绘制（默认false表示顺时针；true表示逆时针） 绘制文本 ctx.font = ‘微软雅黑’ 设置字体 strokeText() fillText(text,x,y,maxWidth) text 要绘制的文本 x,y 文本绘制的坐标（文本左下角） maxWidth 设置文本最大宽度，可选参数 ctx.textAlign文本水平对齐方式，相对绘制坐标来说的 left center right start 默认 end ctx.direction属性css(rtl ltr) start和end于此相关 如果是ltr,start和left表现一致 如果是rtl,start和right表现一致 ctx.textBaseline 设置基线（垂直对齐方式 ） top 文本的基线处于文本的正上方，并且有一段距离 middle 文本的基线处于文本的正中间 bottom 文本的基线处于文本的证下方，并且有一段距离 hanging 文本的基线处于文本的正上方，并且和文本粘合 alphabetic 默认值，基线处于文本的下方，并且穿过文字 ideographic 和bottom相似，但是不一样 measureText() 获取文本宽度obj.width 实例练习 绘制扇形 绘制圆角矩形 绘制圆 绘制饼图 做动画绘制图片 drawImage() 三个参数drawImage(img,x,y) img 图片对象、canvas对象、video对象 x,y 图片绘制的左上角 五个参数drawImage(img,x,y,w,h) img 图片对象、canvas对象、video对象 x,y 图片绘制的左上角 w,h 图片绘制尺寸设置(图片缩放，不是截取) 九个参数drawImage(img,x,y,w,h,x1,y1,w1,h1) img 图片对象、canvas对象、video对象 x,y,w,h 图片中的一个矩形区域 x1,y1,w1,h1 画布中的一个矩形区域 序列帧动画 绘制精灵图 动起来 控制边界 键盘控制 坐标变换 平移 移动画布的原点 translate(x,y) 参数表示移动目标点的坐标 缩放 scale(x,y) 参数表示宽高的缩放比例 旋转 rotate(angle) 参数表示旋转角度 ​]]></content>
      <categories>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6(jspang)]]></title>
    <url>%2F2018%2F12%2F25%2FES6-jspang%2F</url>
    <content type="text"><![CDATA[本文来自于jspang大佬，跟着大佬的博客手撸了一遍。 let 和 const解构赋值数组解构1234let [a, b, c] = [1, 2, 3]console.log(a) // 1console.log(b) // 2console.log(c) // 3 对象解构123let &#123; foo, bar &#125; = &#123; foo: 'hello', bar: 'world' &#125;console.log(foo) // helloconsole.log(bar) // world 字符串解构123456let [a, b, c, d, e] = 'hello'console.log(a) // hconsole.log(b) // econsole.log(c) // lconsole.log(d) // lconsole.log(e) // o 扩展运算符和 rest 运算符扩展运算符1234567function fn(...arg) &#123; console.log(arg[0]) console.log(arg[1]) console.log(arg[2]) console.log(arg[3])&#125;fn(1, 2, 3) //1,2,3,undefined 数组赋值 123let arr1 = ['hello', 'world']let arr2 = [...arr1]// arr2=arr1 不是真正的赋值，是对堆栈的引用 rest 运算符123456function fn(first, ...arg) &#123; for (let val of arg) &#123; console.log(val) &#125;&#125;fn(1, 2, 3, 4) // 2,3,4 字符串模板12let world='world'let blog=`hello$&#123;world&#125; 对运算的支持123let a = 1let b = 2let result = `$&#123;a + b&#125;` // 3 字符串查找 查找是否存在 123let text = 'world'let blog = 'hello world'blog.includes(text) // true 判断开头是否存在 123let text = 'hello'let blog = 'hello world'blog.startsWith(text) // true 判断结尾是否存在 123let text = 'world'let blog = 'hello world'blog.endsWith(text) // true 复制字符串 12let text = 'world'text.repeat(3) // worldworldworld 数字操作整数取值范围操作12let a = Math.pow(2, 53) - 1console.log(a) // 9007199254740991 最大安全整数 1console.log(Number.MAX_SAFE_INTEGER) // 9007199254740991 最小安全整数 1console.log(Number.MIN_SAFE_INTEGER) // -9007199254740991 数字判断和转换 数字验证 12Number.isFinite(11 / 4) // trueNumber.isFinite('hello') // false NaN 验证 1Number.isNaN(NaN) // true 整数判断 12Number.isInteger(12) // trueNumber.isInteger(1.2) // false 安全整数判断 1Number.isSafeInteger(Number.MAX_SAFE_INTEGER) // true 新增的数组知识JSON 数组格式转换 这就是一个标准的 JSON 数组格式，跟普通的 JSON 对比是在最后多了一个 length 属性。只要是这种特殊的 json 格式都可以轻松使用 ES6 的语法转变成数组。 12345678let json = &#123; '0': '前', '1': '后', '2': '全', length: 3&#125;let arr = Array.from(json)console.log(arr) // ["前", "后", "全"] Array.of()方法 把一堆文本或者变量转换成数组 12let arr = Array.of('前', '后', '全')console.log(arr) // ["前", "后", "全"] find()实例方法 find 方法是从数组全查找。在 find 方法全我们需要传入一个匿名函数，函数需要传入三个参数：value：表示当前查找的值。index：表示当前查找的数组索引。arr：表示当前数组。在函数全如果找到符合条件的数组元素就进行 return，并停止查找。 12let arr = [1, 2, 3, 4, 5]console.log(arr.find((value, index, arr) =&gt; value &gt; 3)) // 4 fill()实例方法 fill()也是一个实例方法，它的作用是把数组进行填充，它接收三个参数，第一个参数是填充的变量，第二个是开始填充的位置，第三个是填充到的位置。 123let arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]arr.fill('hello', 2, 5)console.log(arr) // [0, 1, "hello", "hello", "hello", 5, 6, 7, 8, 9] 数组遍历 for…of 循环 打印内容 1234let arr = ['前', '后', '全']for (let val of arr) &#123; console.log(val)&#125; 打印索引 1234let arr = ['前', '后', '全']for (let index of arr.keys()) &#123; console.log(index)&#125; 打印内容+索引 1234let arr = ['前', '后', '全']for (let [index, val] of arr.entries()) &#123; console.log(index + ':' + val)&#125; entries( )实例方法 12345let arr = ['前', '后', '全']let list = arr.entries()console.log(list.next().value) // [0, "前"]console.log(list.next().value) // [1, "后"]console.log(list.next().value) // [2, "全"] 箭头函数数组和函数补漏对象的函数解构12345678let json = &#123; a: '前', b: '后'&#125;function fn(&#123; a, b &#125;) &#123; console.log(a, b)&#125;fn(json) // 前 后 数组的函数解构12345let arr = ['前', '后', '全']function fn(a, b, c) &#123; console.log(a, b, c)&#125;fn(...arr) // 前 后 全 in 的用法 in 是用来判断对象或者数组全是否存在某个值的。 对象判断 12345let obj = &#123; a: 'hello', b: 'world'&#125;console.log('a' in obj) //true 数组判断 12let arr = ['hello', 'world']console.log(0 in arr) //true 数组遍历 forEach 循环的特点是会自动省略为空的数组元素，相当于直接给我们筛空了。当是有时候也会给我们帮倒忙。 forEach 12let arr = ['前', '后', '全']arr.forEach((val, index) =&gt; console.log(index, val)) filter 12let arr = ['前', '后', '全']arr.filter(val =&gt; console.log(val)) some 12let arr = ['前', '后', '全']arr.some(val =&gt; console.log(val)) map map 可以向上面一样做循环，在这里起到一个替换的作用 12let arr = ['前', '后', '全']console.log(arr.map(val =&gt; '中')) ES6 对象SymbolSet Set 和 Array 的区别是 Set 不允许内部有重复的值，如果有只显示一个，相当于去重。虽然 Set 很像数组，但是他不是数组。 12let setArr = new Set([1, 2, 3, 4])console.log(setArr) // Set(4) &#123;1, 2, 3, 4&#125; size 属性 12let setArr = new Set([1, 2, 3, 4])console.log(setArr.size) // 4 Set 的增删查 追加 add 123let setArr = new Set([1, 2, 3, 4])setArr.add(5)console.log(setArr) // Set(4) &#123;1, 2, 3, 4, 5&#125; 删除 delete 1234let setArr = new Set([1, 2, 3, 4])setArr.add(5)setArr.delete(5)console.log(setArr) // Set(4) &#123;1, 2, 3, 4&#125; 查找 has 1234let setArr = new Set([1, 2, 3, 4])console.log(setArr) // Set(4) &#123;1, 2, 3, 4&#125;console.log(setArr.has(1)) // true 清空 clear 123let setArr = new Set([1, 2, 3, 4])setArr.clear()console.log(setArr) // Set(0) &#123;&#125; set 的 for…of 循环 1234let setArr = new Set([1, 2, 3, 4])for (let val of setArr) &#123; console.log(val)&#125; set 的 forEach 循环 12let setArr = new Set([1, 2, 3, 4])setArr.forEach(val =&gt; console.log(val)) weakSet的声明 这里需要注意的是，如果你直接在new 的时候就放入值，将报错.WeakSet里边的值也是不允许重复的1234let weakObj = new WeakSet()let obj = &#123; a: '前', b: '后' &#125;weakObj.add(obj)console.log(weakObj) Map数据结构 Map的灵活性要更好，你可以把它看成一种特殊的键值对，但你的key可以设置成数组，值也可以设置成字符串，让它不规律对应起来。123456789let json = &#123; a:'前', b:'后'&#125;var map=new Map()map.set(json,'全')console.log(map)console.log(map.get(json)) map的增删查 增加set 1map.set(json,'全') 取值get 1console.log(map.get(json)) 删除delete 12map.delete(json);console.log(map) size属性 1console.log(map.size) 查找has 1console.log(map.has(json)) 清空 clear1map.clear() 总结：map在现在开发中已经经常使用，它的灵活性和高效性是我们喜欢的。开发中试着去使用map吧，你一定会喜欢上它的。 用Proxy进行预处理 在运行函数前初始化一些数据，在改变对象值后做一些善后处理。这些都算钩子函数，Proxy的存在就可以让我们给函数加上这样的钩子函数，你也可以理解为在执行方法前预处理一些代码。你可以简单的理解为他是函数或者对象的生命周期。 声明Proxy 我们用new的方法对Proxy进行声明。可以看一下声明Proxy的基本形式。1new Proxy(&#123;&#125;,&#123;&#125;) 需要注意的是这里是两个花括号，第一个花括号就相当于我们方法的主体，后边的花括号就是Proxy代理处理区域，相当于我们写钩子函数的地方。 现在把上边的obj对象改成我们的Proxy形式。123456789101112var pro = new Proxy(&#123; add: function (val) &#123; return val + 10; &#125;, name: 'I am Jspang'&#125;, &#123; get:function(target,key,property)&#123; console.log('come in Get'); return target[key]; &#125; &#125;);console.log(pro.name); 可以在控制台看到结果，先输出了come in Get。相当于在方法调用前的钩子函数。 get属性get属性是在你得到某对象属性值时预处理的方法，他接受三个参数 target：得到的目标值key：目标的key值，相当于对象的属性property：这个不太常用，用法还在研究中，还请大神指教。 set属性set属性是值你要改变Proxy属性值时，进行的预先处理。它接收四个参数。 target:目标值。key：目标的Key值。value：要改变的值。receiver：改变前的原始值。 123456789101112131415161718let pro=new Proxy(&#123; add(val)&#123; return val+10 &#125;, name:'hello world'&#125;,&#123; get(target,key,property)&#123; console.log('come in Get') return target[key] &#125;, set(target,key,value,receiver)&#123; console.log(`set $&#123;key&#125; = $&#123;value&#125;`) return target[key]=value &#125;&#125;)console.log(pro.name)pro.name='你好世界'console.log(pro.name) promise ES6 中的 promise 的出现给我们很好的解决了回调地狱的问题，在使用 ES5 的时候，在多层嵌套回调时，写完的代码层次过多，很难进行维护和二次开发，ES6 认识到了这点问题，现在 promise 的使用，完美解决了这个问题。那我们如何理解 promise 这个单词在 ES5 中的作用那，你可以想象他是一种承诺，当它成功时执行一些代码，当它失败时执行一些代码。它更符合人类的行为思考习惯，而不在是晦涩难懂的冰冷语言。 12345678910111213141516171819202122232425262728293031323334353637383940414243function step1(resolve, reject) &#123; console.log('开始洗菜') if (state == 1) &#123; resolve('洗菜-完成') &#125; else &#123; reject('洗菜-失败') &#125;&#125;function step2(resolve, reject) &#123; console.log('开始吃饭') if (state == 2) &#123; resolve('吃饭-完成') &#125; else &#123; reject('吃饭-失败') &#125;&#125;function step3(resolve, reject) &#123; console.log('开始洗碗') if (state == 3) &#123; resolve('洗碗-完成') &#125; else &#123; reject('洗碗-失败') &#125;&#125;let state = 1new Promise(step1) .then(val =&gt; &#123; console.log(val) state++ return new Promise(step2) &#125;) .then(val =&gt; &#123; console.log(val) state++ return new Promise(step3) &#125;) .then(val =&gt; &#123; console.log(val) return val &#125;) Class 我们在 ES5 中经常使用方法或者对象去模拟类的使用，虽然可以实现功能，但是代码并不优雅，ES6 为我们提供了类的使用。需要注意的是我们在写类的时候和 ES5 中的对象和构造函数要区分开来，不要学混了。 类的声明 我们已经声明了一个类，并在类里声明了 name 方法，现在要实例化类，并使用类中的方法。 12345678class Student &#123; name(val) &#123; console.log(val) return val &#125;&#125;let Tom = new Student()Tom.name('Tom) 类的多方法声明 这里需要注意的是两个方法中间不要写逗号了，还有这里的 this 指类本身，还有要注意 return 的用法。 123456789101112class Student &#123; name(val) &#123; console.log(val) return val &#125; skill(val) &#123; console.log(this.name('Tom' + ' skill ' + val)) &#125;&#125;let Tom = new Student()Tom.name('Tom)Tom.skill('web') 类的传参 在类的参数传递中我们用 constructor( )进行传参。传递参数后可以直接使用 this.xxx 进行调用. 123456789101112131415161718class Student &#123; name(val) &#123; console.log(val) return val &#125; skill(val) &#123; console.log(this.name('Tom' + ' skill ' + val)) &#125; constructor(a, b) &#123; this.a = a this.b = b &#125; add() &#123; return this.a + this.b &#125;&#125;let Tom = new Student(1, 2)console.log(Tom.add()) 我们用 constructor 来约定了传递参数，然后用作了一个 add 方法，把参数相加。这和以前我们的传递方法有些不一样，所以需要小伙伴们多注意下。 class 的继承12345678910111213141516171819202122class Student &#123; name(val) &#123; console.log(val) return val &#125; skill(val) &#123; console.log(this.name('Tom' + ' skill ' + val)) &#125; constructor(a, b) &#123; this.a = a this.b = b &#125; add() &#123; return this.a + this.b &#125;&#125;class Man extends Student &#123;&#125;let Jack = new Man(12, 23)Jack.name('Jack')Jack.skill('java')console.log(Jack.add()) 模块化 在 ES5 中我们要进行模块华操作需要引入第三方类库，随着前后端分离，前端的业务日渐复杂，ES6 为我们增加了模块话操作。模块化操作主要包括两个方面。 export :负责进行模块化，也是模块的输出。 import : 负责把模块引，也是模块的引入操作。 export 的用法： export 可以让我们把变量，函数，对象进行模块话，提供外部调用接口，让外部进行引用。先来看个最简单的例子，把一个变量模块化。我们新建一个 temp.js 文件，然后在文件中输出一个模块变量。 1export var a = 'tom' 然后可以在 index.js 中以 import 的形式引入。 12import &#123; a &#125; from './temp.js'console.log(a) 这就是一个最简单的模块的输出和引入。 多变量的输出这里声明了 3 个变量，需要把这 3 个变量都进行模块化输出，这时候我们给他们包装成对象就可以了。 123var a = 'tom'var b = 'jack'var c = 'web' export {a,b,c} 函数的模块化输出123export function add(a, b) &#123; return a + b&#125; as 的用法 有些时候我们并不想暴露模块里边的变量名称，而给模块起一个更语义话的名称，这时候我们就可以使用 as 来操作。 1234var a = 'tom'var b = 'jack'var c = 'web'export &#123; x as a, y as b, z as c &#125; export default 的使用 加上 default 相当是一个默认的入口。在一个文件里 export default 只能有一个。我们来对比一下 export 和 export default 的区别 1.export 1234export var a = 'tom'export function add(a, b) &#123; return a + b&#125; 对应的导入方式 1import &#123;a,add&#125; form './temp' //也可以分开写 2.export defalut 1export default var a='tom' 对应的引入方式 1import str from './temp']]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6]]></title>
    <url>%2F2018%2F12%2F24%2FES6%2F</url>
    <content type="text"><![CDATA[1.变量声明let和const预解析机制 : var有变量提升的机制12345678910111213function fn()&#123; var a=1 console.log(a)&#125;fn() //1//以上代码等同于：function fn()&#123; var a a=1 console.log(a)&#125;fn() //1 把声明赋值和打印的语句顺序交换12345678910111213function fn()&#123; console.log(a) var a=1&#125;fn() //undefined//以上代码等同于：function fn()&#123; var a console.log(a) a=1&#125;fn() //undefined ES5的解析：从上到下解析，遇到var关键字，就把该声明提前到函数的最顶部，如果不在函数内就提升到全局作用域的最顶部，赋值留在原位，因为先声明了变量a，然后打印，最后再赋值，所以结果就是undefined。但是使用let和const就可以解决变量提升的问题，let代表变量，const代表常量。123456letfunction fn()&#123; let a=1 console.log(a)&#125;fn() //1 把声明赋值和打印的语句顺序交换12345function fn()&#123; console.log(a) let a=1&#125;fn() //Error: a is not defined let不存在变量提升的机制，不会被声明到最顶部，所以未声明就打印，会报错：变量未定义。123constconst PI=3.14PI=3.1415926 //Error: Assignment to constant variable. const的声明必须赋值，赋值之后不可修改。那要怎么修改const的值呢？实际上是const的指向不可修改，但是可以通过更改地址中的内容来修改了const的值。1234567891011121314151617const stu=&#123; name: '小明' &#125;//正确,改变地址中的内容stu.name='小红'//报错,改变了const的指向stu=&#123; name: '小红' &#125;TDZ(暂时性死区)if (true) &#123; // TDZ开始 tmp = 'abc'; console.log(tmp); // Error: tmp is not defined let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125; let 或者 const，会将声明放入TDZ(暂时性死区)，只有执行到变量声明语句时，变量才会从TDZ中取出来使用。总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 块级作用域 ES6在ES5 全局作用域和函数作用域的基础上开拓了块级作用域，使得变量的作用域更加清晰。 内层变量覆盖外层变量12345678var tmp = new Date();function f() &#123; console.log(tmp); var tmp = 'hello world';&#125;f(); // undefined 函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。 用来计数的循环变量泄露为全局变量1234567var s = 'hello';for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); // 5 变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。 ES6新增了块级作用域，即一个{}就是一个块级作用域。12&#123; let a=1 &#125;console.log(a) //报错 不同块级作用域可以定义重名的变量1234&#123; let a='hello world' &#123; let a='hello world' &#125;&#125; 立即执行函数就可以用块级作用域来替代1234567891011// IIFE写法(function()&#123; var a=... ...&#125;)()// 块级作用域写法&#123; var a=... ...&#125; 2.变量的解构赋值数组的解构赋值 解构赋值语法是一个Javascript表达式，这使得可以将数据从数组或对象提取到不同的变量中。 以前为变量赋值，只能直接指定值。123let a = 1let b = 2let c = 3 ES6就可以写成这样1let [a, b, c] = [1, 2, 3] 本质是上述匹配属于一种模式匹配, 也就是只要等号两边的模式相同，左边的变量就会被赋予对应的值。123456789101112131415let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = ["foo", "bar", "baz"];third // "baz"let [head, ...rest] = [1, 2, 3, 4];head // 1rest // [2, 3, 4]let [bar, foo] = [1];bar //1foo //undefined 默认值 解构赋值允许指定默认值12let [ a = 1 ]= [ ]a //1 ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。12let [x = 1] = [undefined];x // 1 12let [x = 1] = [null];x // null null不严格等于undefined，默认值不生效。如果默认值是一个表达式，表示则是惰性求值的，只有在用到的时候才会求值。1234567function fn()&#123; return -1&#125;let [a = fn()]=[]console.log(a) //-1let [b = fn()]=[1]console.log(b) //1 默认值可以引用其他变量，但该变量必须已经声明。1234let [x = 1, y = x] = [] // x=1; y=1let [x = 1, y = x] = [2] // x=2; y=2let [x = 1, y = x] = [1, 2] // x=1; y=2let [x = y, y = 1] = [] // Error: y is not defined x用y做默认值，但是y还没有声明，所以报错。 对象的解构赋值 解构不仅可以用于数组，还可以用于对象。对象的解构赋值与数组不同的是：数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。1234567var &#123;foo,bar&#125; = &#123;foo: 'aaa', bar: 'bbb'&#125;console.log(foo) //aaaconsole.log(bar) //bbb//以上代码等同于：let &#123; foo: foo, bar: bar &#125; = &#123; foo: "aaa", bar: "bbb" &#125;var &#123;baz&#125; = &#123;foo: 'aaa', bar: 'bbb'&#125;console.log(baz) //undefined 以上未找到baz，解构赋值失败。123let &#123; foo: baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;baz // "aaa"foo // Error: foo is not defined foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。12345678let obj = &#123; p: [ 'hello', &#123; y: 'world' &#125; ]&#125;let &#123; p: [x, &#123; y &#125;] &#125; = obj console.log(x,y) //hello word 字符串的解构赋值 字符串的解构赋值，符串会转化成一个类数组的对象。12const [a,b,c,d,e] = 'hello' console.log(a,b,c,d,e) //h e l l o 类数组对象有length属性，所以len是5。12let &#123;length : len&#125; = 'hello';len //5 函数参数的解构赋值 函数的参数也可以使用解构赋值1234function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 3.字符串的扩展模板字符串拼接字符串一直是令人头痛的地方，一旦变量多起来，字符串的拼接就会变得尤为繁琐，而且可读性极低，模板字符串简直就是开发者的福音。用${}嵌入字符串中拼接，有几个变量就用几个${}1234567// es5var name='world'console.log('hello'+name)//es6var name='world'console.log(`hello$&#123;name&#125;`) 在ES5中通过反斜杠()来做多行字符串的拼接，ES6反引号()可以直接搞定。12345678910// es5var msg='hello \world!'// es6const template=` &lt;div&gt; &lt;span&gt;hello world!&lt;/span&gt; &lt;/div&gt;` 对运算的支持1234let a=1let b=2let result=`$&#123;a+b&#125;`console.log(result) //3 字符串是否存在123456789// es5let name = 'Github'let msg = 'hello world,my name is Github'console.log(msg.indexOf(name)) //返回索引值// es6let name = 'Github'let msg = 'hello world,my name is Github'console.log(msg.includes(name)) //返回布尔值,更直观 复制字符串1console.log('hello world|'.repeat(3)) // hello world|hello world|hello world| 4.箭头函数 ES6提供了箭头函数，给函数的创建提供了一种简便方法。三大特点: 省略function关键字 省略return关键字 继承当前上下文的this关键字12345678910111213141516171819// es5[1,2,3].forEach((function (item) &#123; return item + 1&#125;).bind(this))// es6[1,2,3].forEach(item=&gt;item+=1)当参数只有一个时,可以省略(),当函数表达式只有一个时,可以省略&#123;&#125;和return// 一个参数,一个表达式let person = name =&gt; 'hello ' + nameconsole.log(person('world')) //hello world// 多个参数,多个表达式let person = (name,age) =&gt; &#123; const msg = `hello $&#123;name&#125;,age is $&#123;age&#125;` return msg &#125;console.log(person('world',18)) //hello world,age is18 在使用别人的轮子时,因为不熟练经常会报错,那么这些框架是怎么抛出错误的呢?1234567let add = (a,b=1) =&gt;&#123; if(a&lt;=0)&#123; throw new Error('The variable must be greater than 0') &#125; return a+b&#125;console.log(add(0)); // Uncaught Error: The variable must be greater than 0 5.对象扩展功能在对象的键值对重名时,可以这样处理123456789101112131415// es5function person(name,age)&#123; return &#123; name:name, age:age &#125; &#125;// es6function person(name,age)&#123; return &#123; name, age &#125;&#125; ES6改进了为对象字面量方法赋值的语法,可以省略:和function关键字123456789101112131415// es5function person(name)&#123; name, sayHi:function()&#123; console.log('Hi') &#125;&#125;// es6function person(name)&#123; name, sayHi()&#123; console.log('Hi') &#125;&#125; 合并对象123456let obj1=&#123;name:'Github'&#125;let obj2=&#123;sex:'男'&#125;let obj3=&#123;age:18&#125;let obj = Object.assign(&#123;&#125;,obj1,obj2,obj3)console.log(obj) // &#123;name:"Github",sex:"男",age:18&#125; 6.扩展运算符(…)组装数组或者对象12345678910const arr1=[1,2,3]const arr2=[...arr1,4,5,6]console.log(arr2) //[1,2,3,4,5,6]const obj1=&#123; a:1, b:2&#125;const obj2=&#123;...obj1,c:3,d:4&#125;console.log(obj2); //&#123;a:1,b:2,c:3,d:4&#125; 7.promise 在promise之前，回调地狱，可读性差、耦合度高、扩展性低 。promise大大提高了代码的可读性，用同步编程的方式来编写异步代码，极大的降低了代码耦合性而提高了程序的可扩展性。 promise执行多步操作非常好用，现在模仿一个多步操作的过程。把大象装进冰箱需要几步？答：三步，打开冰箱门，把大象塞进去，关上冰箱门。12345678910111213141516171819202122232425262728293031323334353637383940414243let flag = true;function step1(resolve, reject) &#123; console.log('1.开始-打开冰箱门'); if (flag) &#123; resolve('打开冰箱门--完成'); &#125; else &#123; reject('打开冰箱门--出错'); &#125;&#125;function step2(resolve, reject) &#123; console.log('2.开始-把大象塞进去'); if (flag) &#123; resolve('把大象塞进去--完成'); &#125; else &#123; reject('把大象塞进去--出错'); &#125;&#125;function step3(resolve, reject) &#123; console.log('3.开始-关上冰箱门'); if (flag) &#123; resolve('关上冰箱门--完成'); &#125; else &#123; reject('关上冰箱门--出错'); &#125;&#125;new Promise(step1).then(function (val) &#123; console.log(val); return new Promise(step2);&#125;).then(function (val) &#123; console.log(val); return new Promise(step3);&#125;).then(function (val) &#123; console.log(val); return val;&#125;);/* 1.开始-打开冰箱门打开冰箱门--完成2.开始-把大象塞进去把大象塞进去--完成3.开始-关上冰箱门关上冰箱门--完成*/ 8.class类class声明和使用123456789101112131415161718192021// 类的声明class Coder&#123; getName(name)&#123; console.log(name); &#125;&#125;// 类的使用let Github=new CoderGithub.getName('Github') // Github声明一个JsCoder的新类并继承Coder类class Coder&#123; getName(name)&#123; console.log(name); &#125;&#125;class JsCoder extends Coder&#123;&#125;let js=new JsCoderjs.getName('js') 9.模块化 前后端分离，前端业务逻辑也在日益复杂，前端也在借鉴后端的思想，ES6为我们增加了模块化操作来方便我们引用第三方库，尤其是在开发vue项目时，需要依赖大量第三方包，需要我们使用到模块化的思想来开发项目。 import : 引入模块 export : 输出模块12345678910// a.js 导出export var name='hello world'export function add(a,b)&#123; return a+b;&#125;// b.js 导入import &#123; name,add &#125; from "./a.js" //也可以分开导入console.log(name) //hello worldconsole.log(add(1,2)) //3]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode之必备插件推荐]]></title>
    <url>%2F2018%2F12%2F23%2Fvscode%E4%B9%8B%E5%BF%85%E5%A4%87%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[工欲善其事，必先利其器 Auto Close Tag 自动闭合标签 Auto Rename Tag 自动完成另一侧标签的同步修改 Path Intellisense 自动提示文件路径，支持快速引入文件 Open HTML in Default Browser 右键:在浏览器中打开 Live Server vscode不是IDE,可以用Liver Server开启本地服务实现视图热更新 Css Peek 右键单击选择器时，展示当前样式，可直接跳转到定义css的代码位置 Color Picker 拾色器直接在编辑器中选择合适的颜色 cssrem css值转rem vscode-iconsMaterial Icon Theme 图标 One Dark ProOne Monokai Theme 主题 Chinese (Simplified) Language Pack for Visual Studio Code 安装后，在 locale.json 中添加 “locale”: “zh-cn”，即可载入中文（简体）语言包。要修改 locale.json，你可以同时按下 Ctrl+Shift+P 打开命令面板，之后输入 “config” 筛选可用命令列表，最后选择配置语言命令。 Vetur vue语法高亮/格式化/代码片段/语法检查等 GitLens git版本控制 Git Histroy Git的详细信息和图表 Debugger for Chrome 在编辑器中设置断点等调试，用于Chrome Quokka.js 实时调试和展示结果 Faker Faker 可以随机生成姓名、地址、图像、电话号码crtl+shift+p 输入Faker:Name即可随即插入姓名 TODO Highlight 高亮TODO 和FIXME注释，以便追踪任何未完成的业务 小程序开发插件 vscode weapp apivscode wxmlvscode-wechatEasy WXLESS]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
</search>
